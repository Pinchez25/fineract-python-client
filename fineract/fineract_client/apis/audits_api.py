# coding: utf-8

"""
    Apache Fineract REST API

    Apache Fineract is a secure, multi-tenanted microfinance platform. The goal of the Apache Fineract API is to empower developers to build apps on top of the Apache Fineract Platform. The https://cui.fineract.dev[reference app] (username: mifos, password: password) works on the same demo tenant as the interactive links in this documentation. Until we complete the new REST API documentation you still have the legacy documentation available https://fineract.apache.org/legacy-docs/apiLive.htm[here]. Please check https://fineract.apache.org/docs/current[the Fineract documentation] for more information.

    The version of the OpenAPI document: 1.11.0-SNAPSHOT
    Contact: dev@fineract.apache.org
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from fineract_client.models.get_maker_checker_response import GetMakerCheckerResponse
from fineract_client.models.get_maker_checkers_search_template_response import GetMakerCheckersSearchTemplateResponse

from fineract_client.api_client import ApiClient, RequestSerialized
from fineract_client.api_response import ApiResponse
from fineract_client.rest import RESTResponseType


class AuditsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def retrieve_audit_entries(
        self,
        action_name: Annotated[Optional[StrictStr], Field(description="actionName")] = None,
        entity_name: Annotated[Optional[StrictStr], Field(description="entityName")] = None,
        resource_id: Annotated[Optional[StrictInt], Field(description="resourceId")] = None,
        maker_id: Annotated[Optional[StrictInt], Field(description="makerId")] = None,
        maker_date_time_from: Annotated[Optional[StrictStr], Field(description="makerDateTimeFrom")] = None,
        maker_date_time_to: Annotated[Optional[StrictStr], Field(description="makerDateTimeTo")] = None,
        checker_id: Annotated[Optional[StrictInt], Field(description="checkerId")] = None,
        checker_date_time_from: Annotated[Optional[StrictStr], Field(description="checkerDateTimeFrom")] = None,
        checker_date_time_to: Annotated[Optional[StrictStr], Field(description="checkerDateTimeTo")] = None,
        processing_result: Annotated[Optional[StrictInt], Field(description="processingResult")] = None,
        office_id: Annotated[Optional[StrictInt], Field(description="officeId")] = None,
        group_id: Annotated[Optional[StrictInt], Field(description="groupId")] = None,
        client_id: Annotated[Optional[StrictInt], Field(description="clientId")] = None,
        loanid: Annotated[Optional[StrictInt], Field(description="loanid")] = None,
        savings_account_id: Annotated[Optional[StrictInt], Field(description="savingsAccountId")] = None,
        paged: Annotated[Optional[StrictBool], Field(description="paged")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="offset")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="limit")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="orderBy")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="sortOrder")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetMakerCheckerResponse]:
        """List Audits

        Get a 200 list of audits that match the criteria supplied and sorted by audit id in descending order, and are within the requestors' data scope. Also it supports pagination and sorting  Example Requests:  audits  audits?fields=madeOnDate,maker,processingResult  audits?makerDateTimeFrom=2013-03-25 08:00:00&makerDateTimeTo=2013-04-04 18:00:00  audits?officeId=1  audits?officeId=1&includeJson=true

        :param action_name: actionName
        :type action_name: str
        :param entity_name: entityName
        :type entity_name: str
        :param resource_id: resourceId
        :type resource_id: int
        :param maker_id: makerId
        :type maker_id: int
        :param maker_date_time_from: makerDateTimeFrom
        :type maker_date_time_from: str
        :param maker_date_time_to: makerDateTimeTo
        :type maker_date_time_to: str
        :param checker_id: checkerId
        :type checker_id: int
        :param checker_date_time_from: checkerDateTimeFrom
        :type checker_date_time_from: str
        :param checker_date_time_to: checkerDateTimeTo
        :type checker_date_time_to: str
        :param processing_result: processingResult
        :type processing_result: int
        :param office_id: officeId
        :type office_id: int
        :param group_id: groupId
        :type group_id: int
        :param client_id: clientId
        :type client_id: int
        :param loanid: loanid
        :type loanid: int
        :param savings_account_id: savingsAccountId
        :type savings_account_id: int
        :param paged: paged
        :type paged: bool
        :param offset: offset
        :type offset: int
        :param limit: limit
        :type limit: int
        :param order_by: orderBy
        :type order_by: str
        :param sort_order: sortOrder
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retrieve_audit_entries_serialize(
            action_name=action_name,
            entity_name=entity_name,
            resource_id=resource_id,
            maker_id=maker_id,
            maker_date_time_from=maker_date_time_from,
            maker_date_time_to=maker_date_time_to,
            checker_id=checker_id,
            checker_date_time_from=checker_date_time_from,
            checker_date_time_to=checker_date_time_to,
            processing_result=processing_result,
            office_id=office_id,
            group_id=group_id,
            client_id=client_id,
            loanid=loanid,
            savings_account_id=savings_account_id,
            paged=paged,
            offset=offset,
            limit=limit,
            order_by=order_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetMakerCheckerResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def retrieve_audit_entries_with_http_info(
        self,
        action_name: Annotated[Optional[StrictStr], Field(description="actionName")] = None,
        entity_name: Annotated[Optional[StrictStr], Field(description="entityName")] = None,
        resource_id: Annotated[Optional[StrictInt], Field(description="resourceId")] = None,
        maker_id: Annotated[Optional[StrictInt], Field(description="makerId")] = None,
        maker_date_time_from: Annotated[Optional[StrictStr], Field(description="makerDateTimeFrom")] = None,
        maker_date_time_to: Annotated[Optional[StrictStr], Field(description="makerDateTimeTo")] = None,
        checker_id: Annotated[Optional[StrictInt], Field(description="checkerId")] = None,
        checker_date_time_from: Annotated[Optional[StrictStr], Field(description="checkerDateTimeFrom")] = None,
        checker_date_time_to: Annotated[Optional[StrictStr], Field(description="checkerDateTimeTo")] = None,
        processing_result: Annotated[Optional[StrictInt], Field(description="processingResult")] = None,
        office_id: Annotated[Optional[StrictInt], Field(description="officeId")] = None,
        group_id: Annotated[Optional[StrictInt], Field(description="groupId")] = None,
        client_id: Annotated[Optional[StrictInt], Field(description="clientId")] = None,
        loanid: Annotated[Optional[StrictInt], Field(description="loanid")] = None,
        savings_account_id: Annotated[Optional[StrictInt], Field(description="savingsAccountId")] = None,
        paged: Annotated[Optional[StrictBool], Field(description="paged")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="offset")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="limit")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="orderBy")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="sortOrder")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetMakerCheckerResponse]]:
        """List Audits

        Get a 200 list of audits that match the criteria supplied and sorted by audit id in descending order, and are within the requestors' data scope. Also it supports pagination and sorting  Example Requests:  audits  audits?fields=madeOnDate,maker,processingResult  audits?makerDateTimeFrom=2013-03-25 08:00:00&makerDateTimeTo=2013-04-04 18:00:00  audits?officeId=1  audits?officeId=1&includeJson=true

        :param action_name: actionName
        :type action_name: str
        :param entity_name: entityName
        :type entity_name: str
        :param resource_id: resourceId
        :type resource_id: int
        :param maker_id: makerId
        :type maker_id: int
        :param maker_date_time_from: makerDateTimeFrom
        :type maker_date_time_from: str
        :param maker_date_time_to: makerDateTimeTo
        :type maker_date_time_to: str
        :param checker_id: checkerId
        :type checker_id: int
        :param checker_date_time_from: checkerDateTimeFrom
        :type checker_date_time_from: str
        :param checker_date_time_to: checkerDateTimeTo
        :type checker_date_time_to: str
        :param processing_result: processingResult
        :type processing_result: int
        :param office_id: officeId
        :type office_id: int
        :param group_id: groupId
        :type group_id: int
        :param client_id: clientId
        :type client_id: int
        :param loanid: loanid
        :type loanid: int
        :param savings_account_id: savingsAccountId
        :type savings_account_id: int
        :param paged: paged
        :type paged: bool
        :param offset: offset
        :type offset: int
        :param limit: limit
        :type limit: int
        :param order_by: orderBy
        :type order_by: str
        :param sort_order: sortOrder
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retrieve_audit_entries_serialize(
            action_name=action_name,
            entity_name=entity_name,
            resource_id=resource_id,
            maker_id=maker_id,
            maker_date_time_from=maker_date_time_from,
            maker_date_time_to=maker_date_time_to,
            checker_id=checker_id,
            checker_date_time_from=checker_date_time_from,
            checker_date_time_to=checker_date_time_to,
            processing_result=processing_result,
            office_id=office_id,
            group_id=group_id,
            client_id=client_id,
            loanid=loanid,
            savings_account_id=savings_account_id,
            paged=paged,
            offset=offset,
            limit=limit,
            order_by=order_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetMakerCheckerResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def retrieve_audit_entries_without_preload_content(
        self,
        action_name: Annotated[Optional[StrictStr], Field(description="actionName")] = None,
        entity_name: Annotated[Optional[StrictStr], Field(description="entityName")] = None,
        resource_id: Annotated[Optional[StrictInt], Field(description="resourceId")] = None,
        maker_id: Annotated[Optional[StrictInt], Field(description="makerId")] = None,
        maker_date_time_from: Annotated[Optional[StrictStr], Field(description="makerDateTimeFrom")] = None,
        maker_date_time_to: Annotated[Optional[StrictStr], Field(description="makerDateTimeTo")] = None,
        checker_id: Annotated[Optional[StrictInt], Field(description="checkerId")] = None,
        checker_date_time_from: Annotated[Optional[StrictStr], Field(description="checkerDateTimeFrom")] = None,
        checker_date_time_to: Annotated[Optional[StrictStr], Field(description="checkerDateTimeTo")] = None,
        processing_result: Annotated[Optional[StrictInt], Field(description="processingResult")] = None,
        office_id: Annotated[Optional[StrictInt], Field(description="officeId")] = None,
        group_id: Annotated[Optional[StrictInt], Field(description="groupId")] = None,
        client_id: Annotated[Optional[StrictInt], Field(description="clientId")] = None,
        loanid: Annotated[Optional[StrictInt], Field(description="loanid")] = None,
        savings_account_id: Annotated[Optional[StrictInt], Field(description="savingsAccountId")] = None,
        paged: Annotated[Optional[StrictBool], Field(description="paged")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="offset")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="limit")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="orderBy")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="sortOrder")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Audits

        Get a 200 list of audits that match the criteria supplied and sorted by audit id in descending order, and are within the requestors' data scope. Also it supports pagination and sorting  Example Requests:  audits  audits?fields=madeOnDate,maker,processingResult  audits?makerDateTimeFrom=2013-03-25 08:00:00&makerDateTimeTo=2013-04-04 18:00:00  audits?officeId=1  audits?officeId=1&includeJson=true

        :param action_name: actionName
        :type action_name: str
        :param entity_name: entityName
        :type entity_name: str
        :param resource_id: resourceId
        :type resource_id: int
        :param maker_id: makerId
        :type maker_id: int
        :param maker_date_time_from: makerDateTimeFrom
        :type maker_date_time_from: str
        :param maker_date_time_to: makerDateTimeTo
        :type maker_date_time_to: str
        :param checker_id: checkerId
        :type checker_id: int
        :param checker_date_time_from: checkerDateTimeFrom
        :type checker_date_time_from: str
        :param checker_date_time_to: checkerDateTimeTo
        :type checker_date_time_to: str
        :param processing_result: processingResult
        :type processing_result: int
        :param office_id: officeId
        :type office_id: int
        :param group_id: groupId
        :type group_id: int
        :param client_id: clientId
        :type client_id: int
        :param loanid: loanid
        :type loanid: int
        :param savings_account_id: savingsAccountId
        :type savings_account_id: int
        :param paged: paged
        :type paged: bool
        :param offset: offset
        :type offset: int
        :param limit: limit
        :type limit: int
        :param order_by: orderBy
        :type order_by: str
        :param sort_order: sortOrder
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retrieve_audit_entries_serialize(
            action_name=action_name,
            entity_name=entity_name,
            resource_id=resource_id,
            maker_id=maker_id,
            maker_date_time_from=maker_date_time_from,
            maker_date_time_to=maker_date_time_to,
            checker_id=checker_id,
            checker_date_time_from=checker_date_time_from,
            checker_date_time_to=checker_date_time_to,
            processing_result=processing_result,
            office_id=office_id,
            group_id=group_id,
            client_id=client_id,
            loanid=loanid,
            savings_account_id=savings_account_id,
            paged=paged,
            offset=offset,
            limit=limit,
            order_by=order_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetMakerCheckerResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _retrieve_audit_entries_serialize(
        self,
        action_name,
        entity_name,
        resource_id,
        maker_id,
        maker_date_time_from,
        maker_date_time_to,
        checker_id,
        checker_date_time_from,
        checker_date_time_to,
        processing_result,
        office_id,
        group_id,
        client_id,
        loanid,
        savings_account_id,
        paged,
        offset,
        limit,
        order_by,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if action_name is not None:
            
            _query_params.append(('actionName', action_name))
            
        if entity_name is not None:
            
            _query_params.append(('entityName', entity_name))
            
        if resource_id is not None:
            
            _query_params.append(('resourceId', resource_id))
            
        if maker_id is not None:
            
            _query_params.append(('makerId', maker_id))
            
        if maker_date_time_from is not None:
            
            _query_params.append(('makerDateTimeFrom', maker_date_time_from))
            
        if maker_date_time_to is not None:
            
            _query_params.append(('makerDateTimeTo', maker_date_time_to))
            
        if checker_id is not None:
            
            _query_params.append(('checkerId', checker_id))
            
        if checker_date_time_from is not None:
            
            _query_params.append(('checkerDateTimeFrom', checker_date_time_from))
            
        if checker_date_time_to is not None:
            
            _query_params.append(('checkerDateTimeTo', checker_date_time_to))
            
        if processing_result is not None:
            
            _query_params.append(('processingResult', processing_result))
            
        if office_id is not None:
            
            _query_params.append(('officeId', office_id))
            
        if group_id is not None:
            
            _query_params.append(('groupId', group_id))
            
        if client_id is not None:
            
            _query_params.append(('clientId', client_id))
            
        if loanid is not None:
            
            _query_params.append(('loanid', loanid))
            
        if savings_account_id is not None:
            
            _query_params.append(('savingsAccountId', savings_account_id))
            
        if paged is not None:
            
            _query_params.append(('paged', paged))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if order_by is not None:
            
            _query_params.append(('orderBy', order_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'tenantid'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/audits',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def retrieve_audit_entry(
        self,
        audit_id: Annotated[StrictInt, Field(description="auditId")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetMakerCheckerResponse:
        """Retrieve an Audit Entry

        Example Requests:  audits/20 audits/20?fields=madeOnDate,maker,processingResult

        :param audit_id: auditId (required)
        :type audit_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retrieve_audit_entry_serialize(
            audit_id=audit_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetMakerCheckerResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def retrieve_audit_entry_with_http_info(
        self,
        audit_id: Annotated[StrictInt, Field(description="auditId")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetMakerCheckerResponse]:
        """Retrieve an Audit Entry

        Example Requests:  audits/20 audits/20?fields=madeOnDate,maker,processingResult

        :param audit_id: auditId (required)
        :type audit_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retrieve_audit_entry_serialize(
            audit_id=audit_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetMakerCheckerResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def retrieve_audit_entry_without_preload_content(
        self,
        audit_id: Annotated[StrictInt, Field(description="auditId")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve an Audit Entry

        Example Requests:  audits/20 audits/20?fields=madeOnDate,maker,processingResult

        :param audit_id: auditId (required)
        :type audit_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retrieve_audit_entry_serialize(
            audit_id=audit_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetMakerCheckerResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _retrieve_audit_entry_serialize(
        self,
        audit_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if audit_id is not None:
            _path_params['auditId'] = audit_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'tenantid'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/audits/{auditId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def retrieve_audit_search_template(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetMakerCheckersSearchTemplateResponse:
        """Audit Search Template

        This is a convenience resource. It can be useful when building an Audit Search UI. \"appUsers\" are data scoped to the office/branch the requestor is associated with.  Example Requests:  audits/searchtemplate audits/searchtemplate?fields=actionNames

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retrieve_audit_search_template_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetMakerCheckersSearchTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def retrieve_audit_search_template_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetMakerCheckersSearchTemplateResponse]:
        """Audit Search Template

        This is a convenience resource. It can be useful when building an Audit Search UI. \"appUsers\" are data scoped to the office/branch the requestor is associated with.  Example Requests:  audits/searchtemplate audits/searchtemplate?fields=actionNames

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retrieve_audit_search_template_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetMakerCheckersSearchTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def retrieve_audit_search_template_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Audit Search Template

        This is a convenience resource. It can be useful when building an Audit Search UI. \"appUsers\" are data scoped to the office/branch the requestor is associated with.  Example Requests:  audits/searchtemplate audits/searchtemplate?fields=actionNames

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retrieve_audit_search_template_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetMakerCheckersSearchTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _retrieve_audit_search_template_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'tenantid'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/audits/searchtemplate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


