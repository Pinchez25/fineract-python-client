# coding: utf-8

"""
    Apache Fineract REST API

    Apache Fineract is a secure, multi-tenanted microfinance platform. The goal of the Apache Fineract API is to empower developers to build apps on top of the Apache Fineract Platform. The https://cui.fineract.dev[reference app] (username: mifos, password: password) works on the same demo tenant as the interactive links in this documentation. Until we complete the new REST API documentation you still have the legacy documentation available https://fineract.apache.org/legacy-docs/apiLive.htm[here]. Please check https://fineract.apache.org/docs/current[the Fineract documentation] for more information.

    The version of the OpenAPI document: 1.11.0-SNAPSHOT
    Contact: dev@fineract.apache.org
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date
from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from fineract_client.models.charge import Charge
from fineract_client.models.delinquency_bucket import DelinquencyBucket
from fineract_client.models.external_id import ExternalId
from fineract_client.models.fund import Fund
from fineract_client.models.loan_product_borrower_cycle_variations import LoanProductBorrowerCycleVariations
from fineract_client.models.loan_product_guarantee_details import LoanProductGuaranteeDetails
from fineract_client.models.loan_product_interest_recalculation_details import LoanProductInterestRecalculationDetails
from fineract_client.models.loan_product_min_max_constraints import LoanProductMinMaxConstraints
from fineract_client.models.loan_product_related_detail import LoanProductRelatedDetail
from fineract_client.models.loan_product_tranche_details import LoanProductTrancheDetails
from fineract_client.models.monetary_currency import MonetaryCurrency
from fineract_client.models.money import Money
from fineract_client.models.rate import Rate
from typing import Optional, Set
from typing_extensions import Self

class LoanProduct(BaseModel):
    """
    LoanProduct
    """ # noqa: E501
    account_moves_out_of_npa_only_on_arrears_completion: Optional[StrictBool] = Field(default=None, alias="accountMovesOutOfNPAOnlyOnArrearsCompletion")
    accounting_disabled: Optional[StrictBool] = Field(default=None, alias="accountingDisabled")
    accounting_rule: Optional[StrictInt] = Field(default=None, alias="accountingRule")
    allow_approved_disbursed_amounts_over_applied: Optional[StrictBool] = Field(default=None, alias="allowApprovedDisbursedAmountsOverApplied")
    allow_variabe_installments: Optional[StrictBool] = Field(default=None, alias="allowVariabeInstallments")
    arrears_based_on_original_schedule: Optional[StrictBool] = Field(default=None, alias="arrearsBasedOnOriginalSchedule")
    borrower_cycle_variations: Optional[List[LoanProductBorrowerCycleVariations]] = Field(default=None, alias="borrowerCycleVariations")
    can_define_installment_amount: Optional[StrictBool] = Field(default=None, alias="canDefineInstallmentAmount")
    can_use_for_topup: Optional[StrictBool] = Field(default=None, alias="canUseForTopup")
    cash_based_accounting_enabled: Optional[StrictBool] = Field(default=None, alias="cashBasedAccountingEnabled")
    charges: Optional[List[Charge]] = None
    close_date: Optional[date] = Field(default=None, alias="closeDate")
    credit_allocation_rules: Optional[List[LoanProductCreditAllocationRule]] = Field(default=None, alias="creditAllocationRules")
    currency: Optional[MonetaryCurrency] = None
    delinquency_bucket: Optional[DelinquencyBucket] = Field(default=None, alias="delinquencyBucket")
    description: Optional[StrictStr] = None
    disallow_expected_disbursements: Optional[StrictBool] = Field(default=None, alias="disallowExpectedDisbursements")
    due_days_for_repayment_event: Optional[StrictInt] = Field(default=None, alias="dueDaysForRepaymentEvent")
    enable_installment_level_delinquency: Optional[StrictBool] = Field(default=None, alias="enableInstallmentLevelDelinquency")
    equal_amortization: Optional[StrictBool] = Field(default=None, alias="equalAmortization")
    external_id: Optional[ExternalId] = Field(default=None, alias="externalId")
    fixed_principal_percentage_per_installment: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="fixedPrincipalPercentagePerInstallment")
    floating_rates: Optional[LoanProductFloatingRates] = Field(default=None, alias="floatingRates")
    fund: Optional[Fund] = None
    hold_guarantee_funds: Optional[StrictBool] = Field(default=None, alias="holdGuaranteeFunds")
    id: Optional[StrictInt] = None
    include_in_borrower_cycle: Optional[StrictBool] = Field(default=None, alias="includeInBorrowerCycle")
    installment_amount_in_multiples_of: Optional[StrictInt] = Field(default=None, alias="installmentAmountInMultiplesOf")
    interest_period_frequency_type: Optional[StrictStr] = Field(default=None, alias="interestPeriodFrequencyType")
    interest_recalculation_enabled: Optional[StrictBool] = Field(default=None, alias="interestRecalculationEnabled")
    linked_to_floating_interest_rate: Optional[StrictBool] = Field(default=None, alias="linkedToFloatingInterestRate")
    loan_configurable_attributes: Optional[LoanProductConfigurableAttributes] = Field(default=None, alias="loanConfigurableAttributes")
    loan_product_guarantee_details: Optional[LoanProductGuaranteeDetails] = Field(default=None, alias="loanProductGuaranteeDetails")
    loan_product_min_max_constraints: Optional[LoanProductMinMaxConstraints] = Field(default=None, alias="loanProductMinMaxConstraints")
    loan_product_related_detail: Optional[LoanProductRelatedDetail] = Field(default=None, alias="loanProductRelatedDetail")
    loan_product_tranche_details: Optional[LoanProductTrancheDetails] = Field(default=None, alias="loanProductTrancheDetails")
    max_nominal_interest_rate_per_period: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="maxNominalInterestRatePerPeriod")
    max_number_of_repayments: Optional[StrictInt] = Field(default=None, alias="maxNumberOfRepayments")
    max_principal_amount: Optional[Money] = Field(default=None, alias="maxPrincipalAmount")
    min_nominal_interest_rate_per_period: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="minNominalInterestRatePerPeriod")
    min_number_of_repayments: Optional[StrictInt] = Field(default=None, alias="minNumberOfRepayments")
    min_principal_amount: Optional[Money] = Field(default=None, alias="minPrincipalAmount")
    minimum_days_between_disbursal_and_first_repayment: Optional[StrictInt] = Field(default=None, alias="minimumDaysBetweenDisbursalAndFirstRepayment")
    multi_disburse_loan: Optional[StrictBool] = Field(default=None, alias="multiDisburseLoan")
    name: Optional[StrictStr] = None
    new: Optional[StrictBool] = None
    nominal_interest_rate_per_period: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="nominalInterestRatePerPeriod")
    number_of_repayments: Optional[StrictInt] = Field(default=None, alias="numberOfRepayments")
    over_applied_calculation_type: Optional[StrictStr] = Field(default=None, alias="overAppliedCalculationType")
    over_applied_number: Optional[StrictInt] = Field(default=None, alias="overAppliedNumber")
    over_due_days_for_repayment_event: Optional[StrictInt] = Field(default=None, alias="overDueDaysForRepaymentEvent")
    overdue_days_for_npa: Optional[StrictInt] = Field(default=None, alias="overdueDaysForNPA")
    payment_allocation_rules: Optional[List[LoanProductPaymentAllocationRule]] = Field(default=None, alias="paymentAllocationRules")
    periodic_accrual_accounting_enabled: Optional[StrictBool] = Field(default=None, alias="periodicAccrualAccountingEnabled")
    principal_amount: Optional[Money] = Field(default=None, alias="principalAmount")
    principal_threshold_for_last_installment: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="principalThresholdForLastInstallment")
    product_interest_recalculation_details: Optional[LoanProductInterestRecalculationDetails] = Field(default=None, alias="productInterestRecalculationDetails")
    rates: Optional[List[Rate]] = None
    repayment_start_date_type: Optional[StrictStr] = Field(default=None, alias="repaymentStartDateType")
    short_name: Optional[StrictStr] = Field(default=None, alias="shortName")
    start_date: Optional[date] = Field(default=None, alias="startDate")
    sync_expected_with_disbursement_date: Optional[StrictBool] = Field(default=None, alias="syncExpectedWithDisbursementDate")
    transaction_processing_strategy_code: Optional[StrictStr] = Field(default=None, alias="transactionProcessingStrategyCode")
    transaction_processing_strategy_name: Optional[StrictStr] = Field(default=None, alias="transactionProcessingStrategyName")
    upfront_accrual_accounting_enabled: Optional[StrictBool] = Field(default=None, alias="upfrontAccrualAccountingEnabled")
    use_borrower_cycle: Optional[StrictBool] = Field(default=None, alias="useBorrowerCycle")
    variable_installment_config: Optional[LoanProductVariableInstallmentConfig] = Field(default=None, alias="variableInstallmentConfig")
    __properties: ClassVar[List[str]] = ["accountMovesOutOfNPAOnlyOnArrearsCompletion", "accountingDisabled", "accountingRule", "allowApprovedDisbursedAmountsOverApplied", "allowVariabeInstallments", "arrearsBasedOnOriginalSchedule", "borrowerCycleVariations", "canDefineInstallmentAmount", "canUseForTopup", "cashBasedAccountingEnabled", "charges", "closeDate", "creditAllocationRules", "currency", "delinquencyBucket", "description", "disallowExpectedDisbursements", "dueDaysForRepaymentEvent", "enableInstallmentLevelDelinquency", "equalAmortization", "externalId", "fixedPrincipalPercentagePerInstallment", "floatingRates", "fund", "holdGuaranteeFunds", "id", "includeInBorrowerCycle", "installmentAmountInMultiplesOf", "interestPeriodFrequencyType", "interestRecalculationEnabled", "linkedToFloatingInterestRate", "loanConfigurableAttributes", "loanProductGuaranteeDetails", "loanProductMinMaxConstraints", "loanProductRelatedDetail", "loanProductTrancheDetails", "maxNominalInterestRatePerPeriod", "maxNumberOfRepayments", "maxPrincipalAmount", "minNominalInterestRatePerPeriod", "minNumberOfRepayments", "minPrincipalAmount", "minimumDaysBetweenDisbursalAndFirstRepayment", "multiDisburseLoan", "name", "new", "nominalInterestRatePerPeriod", "numberOfRepayments", "overAppliedCalculationType", "overAppliedNumber", "overDueDaysForRepaymentEvent", "overdueDaysForNPA", "paymentAllocationRules", "periodicAccrualAccountingEnabled", "principalAmount", "principalThresholdForLastInstallment", "productInterestRecalculationDetails", "rates", "repaymentStartDateType", "shortName", "startDate", "syncExpectedWithDisbursementDate", "transactionProcessingStrategyCode", "transactionProcessingStrategyName", "upfrontAccrualAccountingEnabled", "useBorrowerCycle", "variableInstallmentConfig"]

    @field_validator('interest_period_frequency_type')
    def interest_period_frequency_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DAYS', 'WEEKS', 'MONTHS', 'YEARS', 'WHOLE_TERM', 'INVALID']):
            raise ValueError("must be one of enum values ('DAYS', 'WEEKS', 'MONTHS', 'YEARS', 'WHOLE_TERM', 'INVALID')")
        return value

    @field_validator('repayment_start_date_type')
    def repayment_start_date_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['INVALID', 'DISBURSEMENT_DATE', 'SUBMITTED_ON_DATE']):
            raise ValueError("must be one of enum values ('INVALID', 'DISBURSEMENT_DATE', 'SUBMITTED_ON_DATE')")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of LoanProduct from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in borrower_cycle_variations (list)
        _items = []
        if self.borrower_cycle_variations:
            for _item in self.borrower_cycle_variations:
                if _item:
                    _items.append(_item.to_dict())
            _dict['borrowerCycleVariations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in charges (list)
        _items = []
        if self.charges:
            for _item in self.charges:
                if _item:
                    _items.append(_item.to_dict())
            _dict['charges'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in credit_allocation_rules (list)
        _items = []
        if self.credit_allocation_rules:
            for _item in self.credit_allocation_rules:
                if _item:
                    _items.append(_item.to_dict())
            _dict['creditAllocationRules'] = _items
        # override the default output from pydantic by calling `to_dict()` of currency
        if self.currency:
            _dict['currency'] = self.currency.to_dict()
        # override the default output from pydantic by calling `to_dict()` of delinquency_bucket
        if self.delinquency_bucket:
            _dict['delinquencyBucket'] = self.delinquency_bucket.to_dict()
        # override the default output from pydantic by calling `to_dict()` of external_id
        if self.external_id:
            _dict['externalId'] = self.external_id.to_dict()
        # override the default output from pydantic by calling `to_dict()` of floating_rates
        if self.floating_rates:
            _dict['floatingRates'] = self.floating_rates.to_dict()
        # override the default output from pydantic by calling `to_dict()` of fund
        if self.fund:
            _dict['fund'] = self.fund.to_dict()
        # override the default output from pydantic by calling `to_dict()` of loan_configurable_attributes
        if self.loan_configurable_attributes:
            _dict['loanConfigurableAttributes'] = self.loan_configurable_attributes.to_dict()
        # override the default output from pydantic by calling `to_dict()` of loan_product_guarantee_details
        if self.loan_product_guarantee_details:
            _dict['loanProductGuaranteeDetails'] = self.loan_product_guarantee_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of loan_product_min_max_constraints
        if self.loan_product_min_max_constraints:
            _dict['loanProductMinMaxConstraints'] = self.loan_product_min_max_constraints.to_dict()
        # override the default output from pydantic by calling `to_dict()` of loan_product_related_detail
        if self.loan_product_related_detail:
            _dict['loanProductRelatedDetail'] = self.loan_product_related_detail.to_dict()
        # override the default output from pydantic by calling `to_dict()` of loan_product_tranche_details
        if self.loan_product_tranche_details:
            _dict['loanProductTrancheDetails'] = self.loan_product_tranche_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of max_principal_amount
        if self.max_principal_amount:
            _dict['maxPrincipalAmount'] = self.max_principal_amount.to_dict()
        # override the default output from pydantic by calling `to_dict()` of min_principal_amount
        if self.min_principal_amount:
            _dict['minPrincipalAmount'] = self.min_principal_amount.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in payment_allocation_rules (list)
        _items = []
        if self.payment_allocation_rules:
            for _item in self.payment_allocation_rules:
                if _item:
                    _items.append(_item.to_dict())
            _dict['paymentAllocationRules'] = _items
        # override the default output from pydantic by calling `to_dict()` of principal_amount
        if self.principal_amount:
            _dict['principalAmount'] = self.principal_amount.to_dict()
        # override the default output from pydantic by calling `to_dict()` of product_interest_recalculation_details
        if self.product_interest_recalculation_details:
            _dict['productInterestRecalculationDetails'] = self.product_interest_recalculation_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in rates (list)
        _items = []
        if self.rates:
            for _item in self.rates:
                if _item:
                    _items.append(_item.to_dict())
            _dict['rates'] = _items
        # override the default output from pydantic by calling `to_dict()` of variable_installment_config
        if self.variable_installment_config:
            _dict['variableInstallmentConfig'] = self.variable_installment_config.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of LoanProduct from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "accountMovesOutOfNPAOnlyOnArrearsCompletion": obj.get("accountMovesOutOfNPAOnlyOnArrearsCompletion"),
            "accountingDisabled": obj.get("accountingDisabled"),
            "accountingRule": obj.get("accountingRule"),
            "allowApprovedDisbursedAmountsOverApplied": obj.get("allowApprovedDisbursedAmountsOverApplied"),
            "allowVariabeInstallments": obj.get("allowVariabeInstallments"),
            "arrearsBasedOnOriginalSchedule": obj.get("arrearsBasedOnOriginalSchedule"),
            "borrowerCycleVariations": [LoanProductBorrowerCycleVariations.from_dict(_item) for _item in obj["borrowerCycleVariations"]] if obj.get("borrowerCycleVariations") is not None else None,
            "canDefineInstallmentAmount": obj.get("canDefineInstallmentAmount"),
            "canUseForTopup": obj.get("canUseForTopup"),
            "cashBasedAccountingEnabled": obj.get("cashBasedAccountingEnabled"),
            "charges": [Charge.from_dict(_item) for _item in obj["charges"]] if obj.get("charges") is not None else None,
            "closeDate": obj.get("closeDate"),
            "creditAllocationRules": [LoanProductCreditAllocationRule.from_dict(_item) for _item in obj["creditAllocationRules"]] if obj.get("creditAllocationRules") is not None else None,
            "currency": MonetaryCurrency.from_dict(obj["currency"]) if obj.get("currency") is not None else None,
            "delinquencyBucket": DelinquencyBucket.from_dict(obj["delinquencyBucket"]) if obj.get("delinquencyBucket") is not None else None,
            "description": obj.get("description"),
            "disallowExpectedDisbursements": obj.get("disallowExpectedDisbursements"),
            "dueDaysForRepaymentEvent": obj.get("dueDaysForRepaymentEvent"),
            "enableInstallmentLevelDelinquency": obj.get("enableInstallmentLevelDelinquency"),
            "equalAmortization": obj.get("equalAmortization"),
            "externalId": ExternalId.from_dict(obj["externalId"]) if obj.get("externalId") is not None else None,
            "fixedPrincipalPercentagePerInstallment": obj.get("fixedPrincipalPercentagePerInstallment"),
            "floatingRates": LoanProductFloatingRates.from_dict(obj["floatingRates"]) if obj.get("floatingRates") is not None else None,
            "fund": Fund.from_dict(obj["fund"]) if obj.get("fund") is not None else None,
            "holdGuaranteeFunds": obj.get("holdGuaranteeFunds"),
            "id": obj.get("id"),
            "includeInBorrowerCycle": obj.get("includeInBorrowerCycle"),
            "installmentAmountInMultiplesOf": obj.get("installmentAmountInMultiplesOf"),
            "interestPeriodFrequencyType": obj.get("interestPeriodFrequencyType"),
            "interestRecalculationEnabled": obj.get("interestRecalculationEnabled"),
            "linkedToFloatingInterestRate": obj.get("linkedToFloatingInterestRate"),
            "loanConfigurableAttributes": LoanProductConfigurableAttributes.from_dict(obj["loanConfigurableAttributes"]) if obj.get("loanConfigurableAttributes") is not None else None,
            "loanProductGuaranteeDetails": LoanProductGuaranteeDetails.from_dict(obj["loanProductGuaranteeDetails"]) if obj.get("loanProductGuaranteeDetails") is not None else None,
            "loanProductMinMaxConstraints": LoanProductMinMaxConstraints.from_dict(obj["loanProductMinMaxConstraints"]) if obj.get("loanProductMinMaxConstraints") is not None else None,
            "loanProductRelatedDetail": LoanProductRelatedDetail.from_dict(obj["loanProductRelatedDetail"]) if obj.get("loanProductRelatedDetail") is not None else None,
            "loanProductTrancheDetails": LoanProductTrancheDetails.from_dict(obj["loanProductTrancheDetails"]) if obj.get("loanProductTrancheDetails") is not None else None,
            "maxNominalInterestRatePerPeriod": obj.get("maxNominalInterestRatePerPeriod"),
            "maxNumberOfRepayments": obj.get("maxNumberOfRepayments"),
            "maxPrincipalAmount": Money.from_dict(obj["maxPrincipalAmount"]) if obj.get("maxPrincipalAmount") is not None else None,
            "minNominalInterestRatePerPeriod": obj.get("minNominalInterestRatePerPeriod"),
            "minNumberOfRepayments": obj.get("minNumberOfRepayments"),
            "minPrincipalAmount": Money.from_dict(obj["minPrincipalAmount"]) if obj.get("minPrincipalAmount") is not None else None,
            "minimumDaysBetweenDisbursalAndFirstRepayment": obj.get("minimumDaysBetweenDisbursalAndFirstRepayment"),
            "multiDisburseLoan": obj.get("multiDisburseLoan"),
            "name": obj.get("name"),
            "new": obj.get("new"),
            "nominalInterestRatePerPeriod": obj.get("nominalInterestRatePerPeriod"),
            "numberOfRepayments": obj.get("numberOfRepayments"),
            "overAppliedCalculationType": obj.get("overAppliedCalculationType"),
            "overAppliedNumber": obj.get("overAppliedNumber"),
            "overDueDaysForRepaymentEvent": obj.get("overDueDaysForRepaymentEvent"),
            "overdueDaysForNPA": obj.get("overdueDaysForNPA"),
            "paymentAllocationRules": [LoanProductPaymentAllocationRule.from_dict(_item) for _item in obj["paymentAllocationRules"]] if obj.get("paymentAllocationRules") is not None else None,
            "periodicAccrualAccountingEnabled": obj.get("periodicAccrualAccountingEnabled"),
            "principalAmount": Money.from_dict(obj["principalAmount"]) if obj.get("principalAmount") is not None else None,
            "principalThresholdForLastInstallment": obj.get("principalThresholdForLastInstallment"),
            "productInterestRecalculationDetails": LoanProductInterestRecalculationDetails.from_dict(obj["productInterestRecalculationDetails"]) if obj.get("productInterestRecalculationDetails") is not None else None,
            "rates": [Rate.from_dict(_item) for _item in obj["rates"]] if obj.get("rates") is not None else None,
            "repaymentStartDateType": obj.get("repaymentStartDateType"),
            "shortName": obj.get("shortName"),
            "startDate": obj.get("startDate"),
            "syncExpectedWithDisbursementDate": obj.get("syncExpectedWithDisbursementDate"),
            "transactionProcessingStrategyCode": obj.get("transactionProcessingStrategyCode"),
            "transactionProcessingStrategyName": obj.get("transactionProcessingStrategyName"),
            "upfrontAccrualAccountingEnabled": obj.get("upfrontAccrualAccountingEnabled"),
            "useBorrowerCycle": obj.get("useBorrowerCycle"),
            "variableInstallmentConfig": LoanProductVariableInstallmentConfig.from_dict(obj["variableInstallmentConfig"]) if obj.get("variableInstallmentConfig") is not None else None
        })
        return _obj

from fineract_client.models.loan_product_configurable_attributes import LoanProductConfigurableAttributes
from fineract_client.models.loan_product_credit_allocation_rule import LoanProductCreditAllocationRule
from fineract_client.models.loan_product_floating_rates import LoanProductFloatingRates
from fineract_client.models.loan_product_payment_allocation_rule import LoanProductPaymentAllocationRule
from fineract_client.models.loan_product_variable_installment_config import LoanProductVariableInstallmentConfig
# TODO: Rewrite to not use raise_errors
LoanProduct.model_rebuild(raise_errors=False)

