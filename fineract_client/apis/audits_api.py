# coding: utf-8

"""
    Apache Fineract REST API

    Apache Fineract is a secure, multi-tenanted microfinance platform. The goal of the Apache Fineract API is to empower developers to build apps on top of the Apache Fineract Platform. The https://cui.fineract.dev[reference app] (username: mifos, password: password) works on the same demo tenant as the interactive links in this documentation. Until we complete the new REST API documentation you still have the legacy documentation available https://fineract.apache.org/legacy-docs/apiLive.htm[here]. Please check https://fineract.apache.org/docs/current[the Fineract documentation] for more information.  # noqa: E501

    OpenAPI spec version: 1.11.0-SNAPSHOT
    Contact: dev@fineract.apache.org
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from fineract_client.api_client import ApiClient


class AuditsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def retrieve_audit_entries(self, **kwargs):  # noqa: E501
        """List Audits  # noqa: E501

        Get a 200 list of audits that match the criteria supplied and sorted by audit id in descending order, and are within the requestors' data scope. Also it supports pagination and sorting  Example Requests:  audits  audits?fields=madeOnDate,maker,processingResult  audits?makerDateTimeFrom=2013-03-25 08:00:00&makerDateTimeTo=2013-04-04 18:00:00  audits?officeId=1  audits?officeId=1&includeJson=true  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_audit_entries(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action_name: actionName
        :param str entity_name: entityName
        :param int resource_id: resourceId
        :param int maker_id: makerId
        :param str maker_date_time_from: makerDateTimeFrom
        :param str maker_date_time_to: makerDateTimeTo
        :param int checker_id: checkerId
        :param str checker_date_time_from: checkerDateTimeFrom
        :param str checker_date_time_to: checkerDateTimeTo
        :param int processing_result: processingResult
        :param int office_id: officeId
        :param int group_id: groupId
        :param int client_id: clientId
        :param int loanid: loanid
        :param int savings_account_id: savingsAccountId
        :param bool paged: paged
        :param int offset: offset
        :param int limit: limit
        :param str order_by: orderBy
        :param str sort_order: sortOrder
        :return: list[GetMakerCheckerResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_audit_entries_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_audit_entries_with_http_info(**kwargs)  # noqa: E501
            return data

    def retrieve_audit_entries_with_http_info(self, **kwargs):  # noqa: E501
        """List Audits  # noqa: E501

        Get a 200 list of audits that match the criteria supplied and sorted by audit id in descending order, and are within the requestors' data scope. Also it supports pagination and sorting  Example Requests:  audits  audits?fields=madeOnDate,maker,processingResult  audits?makerDateTimeFrom=2013-03-25 08:00:00&makerDateTimeTo=2013-04-04 18:00:00  audits?officeId=1  audits?officeId=1&includeJson=true  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_audit_entries_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action_name: actionName
        :param str entity_name: entityName
        :param int resource_id: resourceId
        :param int maker_id: makerId
        :param str maker_date_time_from: makerDateTimeFrom
        :param str maker_date_time_to: makerDateTimeTo
        :param int checker_id: checkerId
        :param str checker_date_time_from: checkerDateTimeFrom
        :param str checker_date_time_to: checkerDateTimeTo
        :param int processing_result: processingResult
        :param int office_id: officeId
        :param int group_id: groupId
        :param int client_id: clientId
        :param int loanid: loanid
        :param int savings_account_id: savingsAccountId
        :param bool paged: paged
        :param int offset: offset
        :param int limit: limit
        :param str order_by: orderBy
        :param str sort_order: sortOrder
        :return: list[GetMakerCheckerResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action_name', 'entity_name', 'resource_id', 'maker_id', 'maker_date_time_from', 'maker_date_time_to', 'checker_id', 'checker_date_time_from', 'checker_date_time_to', 'processing_result', 'office_id', 'group_id', 'client_id', 'loanid', 'savings_account_id', 'paged', 'offset', 'limit', 'order_by', 'sort_order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_audit_entries" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'action_name' in params:
            query_params.append(('actionName', params['action_name']))  # noqa: E501
        if 'entity_name' in params:
            query_params.append(('entityName', params['entity_name']))  # noqa: E501
        if 'resource_id' in params:
            query_params.append(('resourceId', params['resource_id']))  # noqa: E501
        if 'maker_id' in params:
            query_params.append(('makerId', params['maker_id']))  # noqa: E501
        if 'maker_date_time_from' in params:
            query_params.append(('makerDateTimeFrom', params['maker_date_time_from']))  # noqa: E501
        if 'maker_date_time_to' in params:
            query_params.append(('makerDateTimeTo', params['maker_date_time_to']))  # noqa: E501
        if 'checker_id' in params:
            query_params.append(('checkerId', params['checker_id']))  # noqa: E501
        if 'checker_date_time_from' in params:
            query_params.append(('checkerDateTimeFrom', params['checker_date_time_from']))  # noqa: E501
        if 'checker_date_time_to' in params:
            query_params.append(('checkerDateTimeTo', params['checker_date_time_to']))  # noqa: E501
        if 'processing_result' in params:
            query_params.append(('processingResult', params['processing_result']))  # noqa: E501
        if 'office_id' in params:
            query_params.append(('officeId', params['office_id']))  # noqa: E501
        if 'group_id' in params:
            query_params.append(('groupId', params['group_id']))  # noqa: E501
        if 'client_id' in params:
            query_params.append(('clientId', params['client_id']))  # noqa: E501
        if 'loanid' in params:
            query_params.append(('loanid', params['loanid']))  # noqa: E501
        if 'savings_account_id' in params:
            query_params.append(('savingsAccountId', params['savings_account_id']))  # noqa: E501
        if 'paged' in params:
            query_params.append(('paged', params['paged']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'sort_order' in params:
            query_params.append(('sortOrder', params['sort_order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/audits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GetMakerCheckerResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_audit_entry(self, audit_id, **kwargs):  # noqa: E501
        """Retrieve an Audit Entry  # noqa: E501

        Example Requests:  audits/20 audits/20?fields=madeOnDate,maker,processingResult  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_audit_entry(audit_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int audit_id: auditId (required)
        :return: GetMakerCheckerResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_audit_entry_with_http_info(audit_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_audit_entry_with_http_info(audit_id, **kwargs)  # noqa: E501
            return data

    def retrieve_audit_entry_with_http_info(self, audit_id, **kwargs):  # noqa: E501
        """Retrieve an Audit Entry  # noqa: E501

        Example Requests:  audits/20 audits/20?fields=madeOnDate,maker,processingResult  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_audit_entry_with_http_info(audit_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int audit_id: auditId (required)
        :return: GetMakerCheckerResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['audit_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_audit_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'audit_id' is set
        if ('audit_id' not in params or
                params['audit_id'] is None):
            raise ValueError("Missing the required parameter `audit_id` when calling `retrieve_audit_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'audit_id' in params:
            path_params['auditId'] = params['audit_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/audits/{auditId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMakerCheckerResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_audit_search_template(self, **kwargs):  # noqa: E501
        """Audit Search Template  # noqa: E501

        This is a convenience resource. It can be useful when building an Audit Search UI. \"appUsers\" are data scoped to the office/branch the requestor is associated with.  Example Requests:  audits/searchtemplate audits/searchtemplate?fields=actionNames  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_audit_search_template(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetMakerCheckersSearchTemplateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_audit_search_template_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_audit_search_template_with_http_info(**kwargs)  # noqa: E501
            return data

    def retrieve_audit_search_template_with_http_info(self, **kwargs):  # noqa: E501
        """Audit Search Template  # noqa: E501

        This is a convenience resource. It can be useful when building an Audit Search UI. \"appUsers\" are data scoped to the office/branch the requestor is associated with.  Example Requests:  audits/searchtemplate audits/searchtemplate?fields=actionNames  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_audit_search_template_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetMakerCheckersSearchTemplateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_audit_search_template" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/audits/searchtemplate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMakerCheckersSearchTemplateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
