# coding: utf-8

"""
    Apache Fineract REST API

    Apache Fineract is a secure, multi-tenanted microfinance platform. The goal of the Apache Fineract API is to empower developers to build apps on top of the Apache Fineract Platform. The https://cui.fineract.dev[reference app] (username: mifos, password: password) works on the same demo tenant as the interactive links in this documentation. Until we complete the new REST API documentation you still have the legacy documentation available https://fineract.apache.org/legacy-docs/apiLive.htm[here]. Please check https://fineract.apache.org/docs/current[the Fineract documentation] for more information.  # noqa: E501

    OpenAPI spec version: 1.11.0-SNAPSHOT
    Contact: dev@fineract.apache.org
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from fineract_client.api_client import ApiClient


class DataTablesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def advanced_query(self, datatable, **kwargs):  # noqa: E501
        """Query Data Table values  # noqa: E501

        Query values from a registered data table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.advanced_query(datatable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :param PagedLocalRequestAdvancedQueryData body:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.advanced_query_with_http_info(datatable, **kwargs)  # noqa: E501
        else:
            (data) = self.advanced_query_with_http_info(datatable, **kwargs)  # noqa: E501
            return data

    def advanced_query_with_http_info(self, datatable, **kwargs):  # noqa: E501
        """Query Data Table values  # noqa: E501

        Query values from a registered data table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.advanced_query_with_http_info(datatable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :param PagedLocalRequestAdvancedQueryData body:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['datatable', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method advanced_query" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'datatable' is set
        if ('datatable' not in params or
                params['datatable'] is None):
            raise ValueError("Missing the required parameter `datatable` when calling `advanced_query`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'datatable' in params:
            path_params['datatable'] = params['datatable']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables/{datatable}/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_datatable(self, body, **kwargs):  # noqa: E501
        """Create Data Table  # noqa: E501

        Create a new data table and registers it with the Apache Fineract Core application table.  Field Descriptions  Mandatory - datatableName :   The name of the Data Table.  Mandatory - apptableName  Application table name. Must be one of the following:  m_client  m_group  m_loan  m_office  m_saving_account  m_product_loan  m_savings_product  Mandatory - columns   An array of columns in the new Data Table.  Optional - multiRow  Allows to create multiple entries in the Data Table. Optional, defaults to false. If this property is not provided Data Table will allow only one entry.  Field Descriptions - columns  Mandatory - name  Name of the created column. Can contain only alphanumeric characters, underscores and spaces, but cannot start with a number. Cannot start or end with an underscore or space.  Mandatory - type  Column type. Must be one of the following:  Boolean  Date  DateTime  Decimal  Dropdown   Number  String  Text  Mandatory [type = Dropdown] - code  Used in Code description fields. Column name becomes: code_cd_name. Mandatory if using type Dropdown, otherwise an error is returned.  Optional - mandatory  Determines whether this column must have a value in every entry. Optional, defaults to false.  Mandatory [type = String] - length  Length of the text field. Mandatory if type String is used, otherwise an error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_datatable(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostDataTablesRequest body: (required)
        :return: PostDataTablesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_datatable_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_datatable_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_datatable_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Data Table  # noqa: E501

        Create a new data table and registers it with the Apache Fineract Core application table.  Field Descriptions  Mandatory - datatableName :   The name of the Data Table.  Mandatory - apptableName  Application table name. Must be one of the following:  m_client  m_group  m_loan  m_office  m_saving_account  m_product_loan  m_savings_product  Mandatory - columns   An array of columns in the new Data Table.  Optional - multiRow  Allows to create multiple entries in the Data Table. Optional, defaults to false. If this property is not provided Data Table will allow only one entry.  Field Descriptions - columns  Mandatory - name  Name of the created column. Can contain only alphanumeric characters, underscores and spaces, but cannot start with a number. Cannot start or end with an underscore or space.  Mandatory - type  Column type. Must be one of the following:  Boolean  Date  DateTime  Decimal  Dropdown   Number  String  Text  Mandatory [type = Dropdown] - code  Used in Code description fields. Column name becomes: code_cd_name. Mandatory if using type Dropdown, otherwise an error is returned.  Optional - mandatory  Determines whether this column must have a value in every entry. Optional, defaults to false.  Mandatory [type = String] - length  Length of the text field. Mandatory if type String is used, otherwise an error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_datatable_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostDataTablesRequest body: (required)
        :return: PostDataTablesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_datatable" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_datatable`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostDataTablesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_datatable_entry(self, body, datatable, apptable_id, **kwargs):  # noqa: E501
        """Create Entry in Data Table  # noqa: E501

        Adds a row to the data table.  Note that the default datatable UI functionality converts any field name containing spaces to underscores when using the API. This means the field name \"Business Description\" is considered the same as \"Business_Description\". So you shouldn't have both \"versions\" in any data table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_datatable_entry(body, datatable, apptable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: {
  "BusinessDescription": "Livestock sales",
  "Comment": "First comment made",
  "Education_cv": "Primary",
  "Gender_cd": 6,
  "HighestRatePaid": 8.5,
  "NextVisit": "01 October 2012",
  "YearsinBusiness": 5,
  "dateFormat": "dd MMMM yyyy",
  "locale": "en"
} (required)
        :param str datatable: datatable (required)
        :param int apptable_id: apptableId (required)
        :return: PostDataTablesAppTableIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_datatable_entry_with_http_info(body, datatable, apptable_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_datatable_entry_with_http_info(body, datatable, apptable_id, **kwargs)  # noqa: E501
            return data

    def create_datatable_entry_with_http_info(self, body, datatable, apptable_id, **kwargs):  # noqa: E501
        """Create Entry in Data Table  # noqa: E501

        Adds a row to the data table.  Note that the default datatable UI functionality converts any field name containing spaces to underscores when using the API. This means the field name \"Business Description\" is considered the same as \"Business_Description\". So you shouldn't have both \"versions\" in any data table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_datatable_entry_with_http_info(body, datatable, apptable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: {
  "BusinessDescription": "Livestock sales",
  "Comment": "First comment made",
  "Education_cv": "Primary",
  "Gender_cd": 6,
  "HighestRatePaid": 8.5,
  "NextVisit": "01 October 2012",
  "YearsinBusiness": 5,
  "dateFormat": "dd MMMM yyyy",
  "locale": "en"
} (required)
        :param str datatable: datatable (required)
        :param int apptable_id: apptableId (required)
        :return: PostDataTablesAppTableIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'datatable', 'apptable_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_datatable_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_datatable_entry`")  # noqa: E501
        # verify the required parameter 'datatable' is set
        if ('datatable' not in params or
                params['datatable'] is None):
            raise ValueError("Missing the required parameter `datatable` when calling `create_datatable_entry`")  # noqa: E501
        # verify the required parameter 'apptable_id' is set
        if ('apptable_id' not in params or
                params['apptable_id'] is None):
            raise ValueError("Missing the required parameter `apptable_id` when calling `create_datatable_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'datatable' in params:
            path_params['datatable'] = params['datatable']  # noqa: E501
        if 'apptable_id' in params:
            path_params['apptableId'] = params['apptable_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables/{datatable}/{apptableId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostDataTablesAppTableIdResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_datatable(self, datatable_name, **kwargs):  # noqa: E501
        """Delete Data Table  # noqa: E501

        Deletes a data table and deregisters it from the Apache Fineract Core application table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_datatable(datatable_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable_name: datatableName (required)
        :return: DeleteDataTablesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_datatable_with_http_info(datatable_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_datatable_with_http_info(datatable_name, **kwargs)  # noqa: E501
            return data

    def delete_datatable_with_http_info(self, datatable_name, **kwargs):  # noqa: E501
        """Delete Data Table  # noqa: E501

        Deletes a data table and deregisters it from the Apache Fineract Core application table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_datatable_with_http_info(datatable_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable_name: datatableName (required)
        :return: DeleteDataTablesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['datatable_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_datatable" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'datatable_name' is set
        if ('datatable_name' not in params or
                params['datatable_name'] is None):
            raise ValueError("Missing the required parameter `datatable_name` when calling `delete_datatable`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'datatable_name' in params:
            path_params['datatableName'] = params['datatable_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables/{datatableName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeleteDataTablesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_datatable_entries(self, datatable, apptable_id, **kwargs):  # noqa: E501
        """Delete Entry(s) in Data Table  # noqa: E501

        Deletes the entry (if it exists) for data tables that are one-to-one with the application table.  Deletes the entries (if they exist) for data tables that are one-to-many with the application table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_datatable_entries(datatable, apptable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :param int apptable_id: apptableId (required)
        :return: DeleteDataTablesDatatableAppTableIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_datatable_entries_with_http_info(datatable, apptable_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_datatable_entries_with_http_info(datatable, apptable_id, **kwargs)  # noqa: E501
            return data

    def delete_datatable_entries_with_http_info(self, datatable, apptable_id, **kwargs):  # noqa: E501
        """Delete Entry(s) in Data Table  # noqa: E501

        Deletes the entry (if it exists) for data tables that are one-to-one with the application table.  Deletes the entries (if they exist) for data tables that are one-to-many with the application table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_datatable_entries_with_http_info(datatable, apptable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :param int apptable_id: apptableId (required)
        :return: DeleteDataTablesDatatableAppTableIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['datatable', 'apptable_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_datatable_entries" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'datatable' is set
        if ('datatable' not in params or
                params['datatable'] is None):
            raise ValueError("Missing the required parameter `datatable` when calling `delete_datatable_entries`")  # noqa: E501
        # verify the required parameter 'apptable_id' is set
        if ('apptable_id' not in params or
                params['apptable_id'] is None):
            raise ValueError("Missing the required parameter `apptable_id` when calling `delete_datatable_entries`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'datatable' in params:
            path_params['datatable'] = params['datatable']  # noqa: E501
        if 'apptable_id' in params:
            path_params['apptableId'] = params['apptable_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables/{datatable}/{apptableId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeleteDataTablesDatatableAppTableIdResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_datatable_entry(self, datatable, apptable_id, datatable_id, **kwargs):  # noqa: E501
        """Delete Entry in Datatable (One to Many)  # noqa: E501

        Deletes the entry (if it exists) for data tables that are one to many with the application table.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_datatable_entry(datatable, apptable_id, datatable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :param int apptable_id: apptableId (required)
        :param int datatable_id: datatableId (required)
        :return: DeleteDataTablesDatatableAppTableIdDatatableIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_datatable_entry_with_http_info(datatable, apptable_id, datatable_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_datatable_entry_with_http_info(datatable, apptable_id, datatable_id, **kwargs)  # noqa: E501
            return data

    def delete_datatable_entry_with_http_info(self, datatable, apptable_id, datatable_id, **kwargs):  # noqa: E501
        """Delete Entry in Datatable (One to Many)  # noqa: E501

        Deletes the entry (if it exists) for data tables that are one to many with the application table.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_datatable_entry_with_http_info(datatable, apptable_id, datatable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :param int apptable_id: apptableId (required)
        :param int datatable_id: datatableId (required)
        :return: DeleteDataTablesDatatableAppTableIdDatatableIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['datatable', 'apptable_id', 'datatable_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_datatable_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'datatable' is set
        if ('datatable' not in params or
                params['datatable'] is None):
            raise ValueError("Missing the required parameter `datatable` when calling `delete_datatable_entry`")  # noqa: E501
        # verify the required parameter 'apptable_id' is set
        if ('apptable_id' not in params or
                params['apptable_id'] is None):
            raise ValueError("Missing the required parameter `apptable_id` when calling `delete_datatable_entry`")  # noqa: E501
        # verify the required parameter 'datatable_id' is set
        if ('datatable_id' not in params or
                params['datatable_id'] is None):
            raise ValueError("Missing the required parameter `datatable_id` when calling `delete_datatable_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'datatable' in params:
            path_params['datatable'] = params['datatable']  # noqa: E501
        if 'apptable_id' in params:
            path_params['apptableId'] = params['apptable_id']  # noqa: E501
        if 'datatable_id' in params:
            path_params['datatableId'] = params['datatable_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables/{datatable}/{apptableId}/{datatableId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeleteDataTablesDatatableAppTableIdDatatableIdResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deregister_datatable(self, datatable, **kwargs):  # noqa: E501
        """Deregister Data Table  # noqa: E501

        Deregisters a data table. It will no longer be available through the API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deregister_datatable(datatable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :return: PutDataTablesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.deregister_datatable_with_http_info(datatable, **kwargs)  # noqa: E501
        else:
            (data) = self.deregister_datatable_with_http_info(datatable, **kwargs)  # noqa: E501
            return data

    def deregister_datatable_with_http_info(self, datatable, **kwargs):  # noqa: E501
        """Deregister Data Table  # noqa: E501

        Deregisters a data table. It will no longer be available through the API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deregister_datatable_with_http_info(datatable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :return: PutDataTablesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['datatable']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deregister_datatable" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'datatable' is set
        if ('datatable' not in params or
                params['datatable'] is None):
            raise ValueError("Missing the required parameter `datatable` when calling `deregister_datatable`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'datatable' in params:
            path_params['datatable'] = params['datatable']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables/deregister/{datatable}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutDataTablesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_datatable(self, datatable, **kwargs):  # noqa: E501
        """Retrieve Data Table Details  # noqa: E501

        Lists a registered data table details and the Apache Fineract Core application table they are registered to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datatable(datatable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :return: GetDataTablesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_datatable_with_http_info(datatable, **kwargs)  # noqa: E501
        else:
            (data) = self.get_datatable_with_http_info(datatable, **kwargs)  # noqa: E501
            return data

    def get_datatable_with_http_info(self, datatable, **kwargs):  # noqa: E501
        """Retrieve Data Table Details  # noqa: E501

        Lists a registered data table details and the Apache Fineract Core application table they are registered to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datatable_with_http_info(datatable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :return: GetDataTablesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['datatable']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_datatable" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'datatable' is set
        if ('datatable' not in params or
                params['datatable'] is None):
            raise ValueError("Missing the required parameter `datatable` when calling `get_datatable`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'datatable' in params:
            path_params['datatable'] = params['datatable']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables/{datatable}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetDataTablesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_datatable1(self, datatable, apptable_id, **kwargs):  # noqa: E501
        """Retrieve Entry(s) from Data Table  # noqa: E501

        Gets the entry (if it exists) for data tables that are one to one with the application table.  Gets the entries (if they exist) for data tables that are one to many with the application table.  Note: The 'fields' parameter is not available for datatables.  ARGUMENTS orderoptional Specifies the order in which data is returned.genericResultSetoptional, defaults to false If 'true' an optimised JSON format is returned suitable for tabular display of data. This format is used by the default data tables UI functionality. Example Requests:  datatables/extra_client_details/1   datatables/extra_family_details/1?order=`Date of Birth` desc   datatables/extra_client_details/1?genericResultSet=true  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datatable1(datatable, apptable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :param int apptable_id: apptableId (required)
        :param str order: order
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_datatable1_with_http_info(datatable, apptable_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_datatable1_with_http_info(datatable, apptable_id, **kwargs)  # noqa: E501
            return data

    def get_datatable1_with_http_info(self, datatable, apptable_id, **kwargs):  # noqa: E501
        """Retrieve Entry(s) from Data Table  # noqa: E501

        Gets the entry (if it exists) for data tables that are one to one with the application table.  Gets the entries (if they exist) for data tables that are one to many with the application table.  Note: The 'fields' parameter is not available for datatables.  ARGUMENTS orderoptional Specifies the order in which data is returned.genericResultSetoptional, defaults to false If 'true' an optimised JSON format is returned suitable for tabular display of data. This format is used by the default data tables UI functionality. Example Requests:  datatables/extra_client_details/1   datatables/extra_family_details/1?order=`Date of Birth` desc   datatables/extra_client_details/1?genericResultSet=true  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datatable1_with_http_info(datatable, apptable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :param int apptable_id: apptableId (required)
        :param str order: order
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['datatable', 'apptable_id', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_datatable1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'datatable' is set
        if ('datatable' not in params or
                params['datatable'] is None):
            raise ValueError("Missing the required parameter `datatable` when calling `get_datatable1`")  # noqa: E501
        # verify the required parameter 'apptable_id' is set
        if ('apptable_id' not in params or
                params['apptable_id'] is None):
            raise ValueError("Missing the required parameter `apptable_id` when calling `get_datatable1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'datatable' in params:
            path_params['datatable'] = params['datatable']  # noqa: E501
        if 'apptable_id' in params:
            path_params['apptableId'] = params['apptable_id']  # noqa: E501

        query_params = []
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables/{datatable}/{apptableId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_datatable_many_entry(self, datatable, apptable_id, datatable_id, **kwargs):  # noqa: E501
        """get_datatable_many_entry  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datatable_many_entry(datatable, apptable_id, datatable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: (required)
        :param int apptable_id: (required)
        :param int datatable_id: (required)
        :param str order:
        :param bool generic_result_set: Optional flag to format the response
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_datatable_many_entry_with_http_info(datatable, apptable_id, datatable_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_datatable_many_entry_with_http_info(datatable, apptable_id, datatable_id, **kwargs)  # noqa: E501
            return data

    def get_datatable_many_entry_with_http_info(self, datatable, apptable_id, datatable_id, **kwargs):  # noqa: E501
        """get_datatable_many_entry  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datatable_many_entry_with_http_info(datatable, apptable_id, datatable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: (required)
        :param int apptable_id: (required)
        :param int datatable_id: (required)
        :param str order:
        :param bool generic_result_set: Optional flag to format the response
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['datatable', 'apptable_id', 'datatable_id', 'order', 'generic_result_set']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_datatable_many_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'datatable' is set
        if ('datatable' not in params or
                params['datatable'] is None):
            raise ValueError("Missing the required parameter `datatable` when calling `get_datatable_many_entry`")  # noqa: E501
        # verify the required parameter 'apptable_id' is set
        if ('apptable_id' not in params or
                params['apptable_id'] is None):
            raise ValueError("Missing the required parameter `apptable_id` when calling `get_datatable_many_entry`")  # noqa: E501
        # verify the required parameter 'datatable_id' is set
        if ('datatable_id' not in params or
                params['datatable_id'] is None):
            raise ValueError("Missing the required parameter `datatable_id` when calling `get_datatable_many_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'datatable' in params:
            path_params['datatable'] = params['datatable']  # noqa: E501
        if 'apptable_id' in params:
            path_params['apptableId'] = params['apptable_id']  # noqa: E501
        if 'datatable_id' in params:
            path_params['datatableId'] = params['datatable_id']  # noqa: E501

        query_params = []
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501
        if 'generic_result_set' in params:
            query_params.append(('genericResultSet', params['generic_result_set']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables/{datatable}/{apptableId}/{datatableId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_datatables(self, **kwargs):  # noqa: E501
        """List Data Tables  # noqa: E501

        Lists registered data tables and the Apache Fineract Core application table they are registered to.  ARGUMENTS  apptable  - optional The Apache Fineract core application table.  Example Requests:  datatables?apptable=m_client   datatables  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datatables(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str apptable: apptable
        :return: list[GetDataTablesResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_datatables_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_datatables_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_datatables_with_http_info(self, **kwargs):  # noqa: E501
        """List Data Tables  # noqa: E501

        Lists registered data tables and the Apache Fineract Core application table they are registered to.  ARGUMENTS  apptable  - optional The Apache Fineract core application table.  Example Requests:  datatables?apptable=m_client   datatables  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datatables_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str apptable: apptable
        :return: list[GetDataTablesResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['apptable']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_datatables" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'apptable' in params:
            query_params.append(('apptable', params['apptable']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GetDataTablesResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_values(self, datatable, **kwargs):  # noqa: E501
        """Query Data Table values  # noqa: E501

        Query values from a registered data table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_values(datatable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :param str column_filter: columnFilter
        :param str value_filter: valueFilter
        :param str result_columns: resultColumns
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.query_values_with_http_info(datatable, **kwargs)  # noqa: E501
        else:
            (data) = self.query_values_with_http_info(datatable, **kwargs)  # noqa: E501
            return data

    def query_values_with_http_info(self, datatable, **kwargs):  # noqa: E501
        """Query Data Table values  # noqa: E501

        Query values from a registered data table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_values_with_http_info(datatable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :param str column_filter: columnFilter
        :param str value_filter: valueFilter
        :param str result_columns: resultColumns
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['datatable', 'column_filter', 'value_filter', 'result_columns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_values" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'datatable' is set
        if ('datatable' not in params or
                params['datatable'] is None):
            raise ValueError("Missing the required parameter `datatable` when calling `query_values`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'datatable' in params:
            path_params['datatable'] = params['datatable']  # noqa: E501

        query_params = []
        if 'column_filter' in params:
            query_params.append(('columnFilter', params['column_filter']))  # noqa: E501
        if 'value_filter' in params:
            query_params.append(('valueFilter', params['value_filter']))  # noqa: E501
        if 'result_columns' in params:
            query_params.append(('resultColumns', params['result_columns']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables/{datatable}/query', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_datatable(self, datatable, apptable, **kwargs):  # noqa: E501
        """Register Data Table  # noqa: E501

        Registers a data table with the Apache Fineract Core application table. This allows the data table to be maintained through the API. In case the datatable is a PPI (survey table), a parameter category should be pass along with the request. The API currently support one category (200)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_datatable(datatable, apptable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :param str apptable: apptable (required)
        :param PostDataTablesRegisterDatatableAppTable body:
        :return: PutDataTablesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.register_datatable_with_http_info(datatable, apptable, **kwargs)  # noqa: E501
        else:
            (data) = self.register_datatable_with_http_info(datatable, apptable, **kwargs)  # noqa: E501
            return data

    def register_datatable_with_http_info(self, datatable, apptable, **kwargs):  # noqa: E501
        """Register Data Table  # noqa: E501

        Registers a data table with the Apache Fineract Core application table. This allows the data table to be maintained through the API. In case the datatable is a PPI (survey table), a parameter category should be pass along with the request. The API currently support one category (200)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_datatable_with_http_info(datatable, apptable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str datatable: datatable (required)
        :param str apptable: apptable (required)
        :param PostDataTablesRegisterDatatableAppTable body:
        :return: PutDataTablesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['datatable', 'apptable', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_datatable" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'datatable' is set
        if ('datatable' not in params or
                params['datatable'] is None):
            raise ValueError("Missing the required parameter `datatable` when calling `register_datatable`")  # noqa: E501
        # verify the required parameter 'apptable' is set
        if ('apptable' not in params or
                params['apptable'] is None):
            raise ValueError("Missing the required parameter `apptable` when calling `register_datatable`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'datatable' in params:
            path_params['datatable'] = params['datatable']  # noqa: E501
        if 'apptable' in params:
            path_params['apptable'] = params['apptable']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables/register/{datatable}/{apptable}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutDataTablesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_datatable(self, body, datatable_name, **kwargs):  # noqa: E501
        """Update Data Table  # noqa: E501

        Modifies fields of a data table. If the apptableName parameter is passed, data table is deregistered and registered with the new application table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_datatable(body, datatable_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutDataTablesRequest body: (required)
        :param str datatable_name: datatableName (required)
        :return: PutDataTablesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_datatable_with_http_info(body, datatable_name, **kwargs)  # noqa: E501
        else:
            (data) = self.update_datatable_with_http_info(body, datatable_name, **kwargs)  # noqa: E501
            return data

    def update_datatable_with_http_info(self, body, datatable_name, **kwargs):  # noqa: E501
        """Update Data Table  # noqa: E501

        Modifies fields of a data table. If the apptableName parameter is passed, data table is deregistered and registered with the new application table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_datatable_with_http_info(body, datatable_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutDataTablesRequest body: (required)
        :param str datatable_name: datatableName (required)
        :return: PutDataTablesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'datatable_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_datatable" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_datatable`")  # noqa: E501
        # verify the required parameter 'datatable_name' is set
        if ('datatable_name' not in params or
                params['datatable_name'] is None):
            raise ValueError("Missing the required parameter `datatable_name` when calling `update_datatable`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'datatable_name' in params:
            path_params['datatableName'] = params['datatable_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables/{datatableName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutDataTablesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_datatable_entry_one_to_many(self, body, datatable, apptable_id, datatable_id, **kwargs):  # noqa: E501
        """Update Entry in Data Table (One to Many)  # noqa: E501

        Updates the row (if it exists) of the data table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_datatable_entry_one_to_many(body, datatable, apptable_id, datatable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: (required)
        :param str datatable: datatable (required)
        :param int apptable_id: apptableId (required)
        :param int datatable_id: datatableId (required)
        :return: PutDataTablesAppTableIdDatatableIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_datatable_entry_one_to_many_with_http_info(body, datatable, apptable_id, datatable_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_datatable_entry_one_to_many_with_http_info(body, datatable, apptable_id, datatable_id, **kwargs)  # noqa: E501
            return data

    def update_datatable_entry_one_to_many_with_http_info(self, body, datatable, apptable_id, datatable_id, **kwargs):  # noqa: E501
        """Update Entry in Data Table (One to Many)  # noqa: E501

        Updates the row (if it exists) of the data table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_datatable_entry_one_to_many_with_http_info(body, datatable, apptable_id, datatable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: (required)
        :param str datatable: datatable (required)
        :param int apptable_id: apptableId (required)
        :param int datatable_id: datatableId (required)
        :return: PutDataTablesAppTableIdDatatableIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'datatable', 'apptable_id', 'datatable_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_datatable_entry_one_to_many" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_datatable_entry_one_to_many`")  # noqa: E501
        # verify the required parameter 'datatable' is set
        if ('datatable' not in params or
                params['datatable'] is None):
            raise ValueError("Missing the required parameter `datatable` when calling `update_datatable_entry_one_to_many`")  # noqa: E501
        # verify the required parameter 'apptable_id' is set
        if ('apptable_id' not in params or
                params['apptable_id'] is None):
            raise ValueError("Missing the required parameter `apptable_id` when calling `update_datatable_entry_one_to_many`")  # noqa: E501
        # verify the required parameter 'datatable_id' is set
        if ('datatable_id' not in params or
                params['datatable_id'] is None):
            raise ValueError("Missing the required parameter `datatable_id` when calling `update_datatable_entry_one_to_many`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'datatable' in params:
            path_params['datatable'] = params['datatable']  # noqa: E501
        if 'apptable_id' in params:
            path_params['apptableId'] = params['apptable_id']  # noqa: E501
        if 'datatable_id' in params:
            path_params['datatableId'] = params['datatable_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables/{datatable}/{apptableId}/{datatableId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutDataTablesAppTableIdDatatableIdResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_datatable_entry_oneto_one(self, body, datatable, apptable_id, **kwargs):  # noqa: E501
        """Update Entry in Data Table (One to One)  # noqa: E501

        Updates the row (if it exists) of the data table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_datatable_entry_oneto_one(body, datatable, apptable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: (required)
        :param str datatable: datatable (required)
        :param int apptable_id: apptableId (required)
        :return: PutDataTablesAppTableIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_datatable_entry_oneto_one_with_http_info(body, datatable, apptable_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_datatable_entry_oneto_one_with_http_info(body, datatable, apptable_id, **kwargs)  # noqa: E501
            return data

    def update_datatable_entry_oneto_one_with_http_info(self, body, datatable, apptable_id, **kwargs):  # noqa: E501
        """Update Entry in Data Table (One to One)  # noqa: E501

        Updates the row (if it exists) of the data table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_datatable_entry_oneto_one_with_http_info(body, datatable, apptable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: (required)
        :param str datatable: datatable (required)
        :param int apptable_id: apptableId (required)
        :return: PutDataTablesAppTableIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'datatable', 'apptable_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_datatable_entry_oneto_one" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_datatable_entry_oneto_one`")  # noqa: E501
        # verify the required parameter 'datatable' is set
        if ('datatable' not in params or
                params['datatable'] is None):
            raise ValueError("Missing the required parameter `datatable` when calling `update_datatable_entry_oneto_one`")  # noqa: E501
        # verify the required parameter 'apptable_id' is set
        if ('apptable_id' not in params or
                params['apptable_id'] is None):
            raise ValueError("Missing the required parameter `apptable_id` when calling `update_datatable_entry_oneto_one`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'datatable' in params:
            path_params['datatable'] = params['datatable']  # noqa: E501
        if 'apptable_id' in params:
            path_params['apptableId'] = params['apptable_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'tenantid']  # noqa: E501

        return self.api_client.call_api(
            '/v1/datatables/{datatable}/{apptableId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutDataTablesAppTableIdResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
